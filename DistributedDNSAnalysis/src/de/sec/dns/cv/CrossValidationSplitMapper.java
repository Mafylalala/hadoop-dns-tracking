package de.sec.dns.cv;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Map;
import java.util.Set;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.ObjectWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;

import de.sec.dns.dataset.Instance;
import de.sec.dns.util.Util;

/**
 * The cross validation split mapper for {@link CrossValidationSplitTool}. It
 * selects a given number of users at random and hands their instances to the
 * reducer without further changes. The (more heavy) work of re-arranging the
 * instances is left for the reducer.
 * 
 * @author Dominik Herrmann
 */
public class CrossValidationSplitMapper extends
		Mapper<LongWritable, ObjectWritable, Text, Text> {

	static int instances = 0;

	/**
	 * A temporary variable used as mapreduce key.
	 */
	private Text k = new Text();

	/**
	 * is set by setup method in case of fatal failure
	 */
	private Exception setupFailedException;

	/**
	 * A temporary variable used as mapreduce value.
	 */
	private Text v = new Text();

	/**
	 * The occurence matrix contains users and their sessions: user1 ->
	 * date1,date2,...; user2 -> date5,date6,...
	 * 
	 */
	private Map<String, Set<String>> occurrenceMatrix;

	private Map<String, Set<String>> selectedUsersAndSessions;

	@Override
	public void map(LongWritable key, ObjectWritable obj, Context context)
			throws IOException, InterruptedException {
		Instance instance;
		String classLabel;

		if (setupFailedException != null) {
			throw new IOException(setupFailedException);
		}

		FileSplit file = (FileSplit) context.getInputSplit();

		// Extract date from path
		String date = file.getPath().getParent().getName();

		instance = (Instance) obj.get();

		classLabel = instance.getClassLabel();

		// if thisuser-instance belongs to the set of "selected instances"
		// we have to hand it over to the reducer, otherwise we drop it
		if (!selectedUsersAndSessions.containsKey(classLabel))
			return;

		if (!selectedUsersAndSessions.get(classLabel).contains(date))
			return;

		k.set(instance.getClassLabel());
		v.set(instance.toString());
		context.write(k, v);

	}

	/**
	 * Reads the occurence matrix generated by GenerateDataSetHeader in order to
	 * determine the available users. Selects users randomly based on a given
	 * seed. Selects random sessions from each user (meeting the requirements
	 * specified on the command line). Users without a sufficient number of
	 * sessions are not considered.
	 * 
	 * The map method will filter the dataset according to the user-sessions
	 * chosen here.
	 */
	@Override
	public void setup(Context context) {
		Configuration conf = context.getConfiguration();

		// this is the minimum number of sessions as required on the command
		// line
		int numInstancesPerClass = conf.getInt(
				Util.CONF_CROSS_VALIDATION_NUM_INSTANCES_PER_CLASS, 0);

		// this is the number of users as required on the command line
		int numOfClasses = conf.getInt(
				Util.CONF_CROSS_VALIDATION_NUM_OF_CLASSES, 0);

		long seed = conf.getLong(Util.CONF_CROSS_VALIDATION_SEED, 0);

		// read occurrence matrix
		// select all users having the required number of sessions (in
		// Util.getOccurenceMatrix)
		try {
			occurrenceMatrix = Util.getOccurenceMatrix(conf,
					numInstancesPerClass);
		} catch (IOException e) {
			setupFailedException = e;
			return;
		}

		// if we cannot find enough users meeting the requirements, we
		// explicitly fail
		if (occurrenceMatrix.size() < numOfClasses)
			setupFailedException = new Exception(
					"Cannot find enough users meeting the num-instances-per-class requirement.");

		// select the required users at random
		// select the required sessions for each users at random
		selectedUsersAndSessions = Util.selectUsersAndSessionsRandomly(
				occurrenceMatrix, numOfClasses, numInstancesPerClass, seed);

		// write out the userIndex for cross validation

		String[] sortedUsers = selectedUsersAndSessions.keySet().toArray(
				new String[selectedUsersAndSessions.size()]);
		Arrays.sort(sortedUsers);

		try {
			FileSystem fs = FileSystem.get(conf);

			Path headerPath = new Path(
					conf.get(Util.CONF_CROSS_VALIDATION_PATH))
					.suffix("/header/userIndex/header-r-00000");
			FSDataOutputStream out = fs.create(headerPath);
			PrintWriter w = new PrintWriter(out);
			for (String user : sortedUsers) {
				w.println(user + "\t0");
			}
			w.close();
		} catch (IOException e) {
			setupFailedException = e;
			return;
		}
	}
}